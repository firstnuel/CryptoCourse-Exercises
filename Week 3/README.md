# Week 3: Stream ciphers and hash functions

### Task 1: Stream cipher usage

Task 1.1
- The ciphertext for "Move the chairs to the house as soon as possible!" that will decrypt to the desired plaintext under the same keystream used for "Move the tables to the patio as soon as possible!" is:

  a7896ad1b2f7da8d40a434173df74a839a88b5c9a97625e65e16bfebfb542072595d804d5ad1a3af11ea7244a39d76cde1

- Code used
   ````py
   # Original and desired plaintexts
  original_plaintext = "Move the tables to the patio as soon as possible!"
  desired_plaintext = "Move the chairs to the house as soon as possible!"
  
  # Provided ciphertext for the original plaintext
  original_ciphertext_hex = "a7896ad1b2f7da8d40b33d1438e04a839a88b5c9a97625fe5017a5e1fb542072595d804d5ad1a3af11ea7244a39d76cde1"
  
  # Convert hex ciphertext to bytes
  original_ciphertext_bytes = bytes.fromhex(original_ciphertext_hex)
  
  # Function to XOR two byte sequences
  def xor_bytes(byte_seq1, byte_seq2):
      return bytes(a ^ b for a, b in zip(byte_seq1, byte_seq2))
  
  # Generating the keystream by XORing the original plaintext with its ciphertext
  keystream = xor_bytes(original_plaintext.encode(), original_ciphertext_bytes)
  
  # Encrypting the desired plaintext with the keystream
  desired_ciphertext_bytes = xor_bytes(desired_plaintext.encode(), keystream)
  
  # Converting the desired ciphertext to hexadecimal representation
  desired_ciphertext_hex = desired_ciphertext_bytes.hex()
  
  desired_ciphertext_hex
   
  ````


- This ciphertext was generated by XORing the desired plaintext with the keystream derived from the original plaintext and its provided ciphertext. Notice that the beginning and ending parts of the ciphertext are the same for both messages. This similarity occurs because the same segments of plaintext ("Move the" and "as soon as possible!") were encrypted with the same part of the keystream.


Task 1.2

To illustrate the process of encryption with a key and nonce, and to observe the effects of slight changes in the plaintext with different keys but the same nonce.

1. Selected Messages:

- Message 1: "Big high dive!"
- Message 2: "Big high five!"!" (changed 'D' to 'F')
  
2. Chosen Keys and Nonce:

- Key 1: "key12345key12345" (16 bytes for AES)
- Key 2: "key54321key54321" (another 16 bytes key)
- Nonce: "nonce1234567890" (16 bytes)
  
3. Encryption Process:

- Using AES in CTR (Counter) mode for encryption, as it allows the use of a nonce.
Encrypt both messages with their respective keys and the same nonce.

4. Observation:

- Ciphertext for "Big high dive!": 234886ed8efb00787f51cfba770a
- Ciphertext for "Big high five!": 7ee6dbfae3001e35e29107bbb4be

- When comparing these ciphertexts, we find no obvious pattern or relationship between them. The change from 'd' to 'f' in the plaintexts does not result in a recognizable pattern in the ciphertexts when different keys are used, even with the same nonce. This absence of a visible relationship is a fundamental aspect of secure encryption: even small changes in plaintext or the use of different keys should result in completely unrelated and seemingly random ciphertexts. This characteristic ensures the security and confidentiality of the encrypted data. ​​

- Code used
  ````py
    #  Messages
  message_1 = "Big high dive!"
  message_2 = "Big high five!" # 'd' changed to 'f'
  
  # Encrypt both messages using the defined function and keys
  ciphertext_1 = encrypt_aes_ctr(message_1, key1, nonce)
  ciphertext_2 = encrypt_aes_ctr(message_2, key2, nonce)
  
  # Convert ciphertexts to hex for easier comparison
  ciphertext1_hex = ciphertext_1.hex()
  ciphertext2_hex = ciphertext_2.hex()
  
  ciphertext1_hex, ciphertext2_hex
  ````
Task 1.3

Comparing the encryption speed of AES-CBC, AES-CTR, and a selected stream cipher, I will conduct a basic performance test in Python. For the stream cipher, I'll use ChaCha20, a widely-used and secure stream cipher. The test will involve encrypting a reasonably large amount of data to minimize the impact of system noise on the results.

Test Setup
- Data Size: To encrypt a large enough data block, such as 10 MB, to ensure the results are not heavily influenced by system overhead or noise.

Cipher Configuration:
- AES-CBC and AES-CTR: Both use a 256-bit key.

- ChaCha20: Uses its standard configuration.

Performance Measurement
- To measure the time taken to encrypt the data for each cipher.
The encryption times for the 10 MB data using different ciphers are as follows:

- AES-CBC: Approximately 0.0236 seconds
- AES-CTR: Approximately 0.0097 seconds
- ChaCha20: Approximately 0.027 seconds
  
Observations:
- AES-CTR is the fastest, which aligns with the expectation that counter mode (CTR) generally has a performance advantage due to its parallelizable nature and simpler implementation.
- AES-CBC is faster on my system compared to ChaCha20, which is quite interesting. This could be due to hardware acceleration for AES (like AES-NI) being present on my system. AES-NI significantly boosts AES encryption/decryption speeds and is commonly available in modern processors.
- ChaCha20, while slower than both AES modes on my system, still shows a competitive performance. This cipher is often favored in environments where hardware acceleration for AES is not available, as it provides a good balance of security and performance, especially on mobile and lower-power devices.

Hardware Support:
- The Python environment used for this test does not explicitly utilize hardware acceleration features like AES-NI, which are available in modern CPUs for AES encryption.
On systems with hardware acceleration, AES encryption (both CBC and CTR modes) would likely be significantly faster, possibly outperforming ChaCha20.

Conclusion:
- The difference in encryption speed is noticeable but not drastic in this test environment. However, the actual performance can vary based on the hardware and specific implementation.
In more practical applications, the choice between these ciphers should also consider factors like security requirements, hardware capabilities, and the specific nature of the data and system architecture

- Code Used
  ````py
  import time
  from Crypto.Cipher import AES, ChaCha20
  from Crypto.Random import get_random_bytes
  
  # Test data setup
  data = get_random_bytes(10 * 1024 * 1024)  # 10 MB of random data
  key_aes = get_random_bytes(32)  # 256-bit key for AES
  key_chacha20 = get_random_bytes(32)  # 256-bit key for ChaCha20
  iv = get_random_bytes(16)  # Initialization vector for AES-CBC
  nonce = get_random_bytes(8)  # Nonce for AES-CTR and ChaCha20
  
  # Function to measure encryption time
  def measure_encryption_time(cipher, data):
      start_time = time.time()
      cipher.encrypt(data)
      end_time = time.time()
      return end_time - start_time
  
  # AES-CBC
  cipher_aes_cbc = AES.new(key_aes, AES.MODE_CBC, iv)
  time_aes_cbc = measure_encryption_time(cipher_aes_cbc, data)
  
  # AES-CTR
  cipher_aes_ctr = AES.new(key_aes, AES.MODE_CTR, nonce=nonce)
  time_aes_ctr = measure_encryption_time(cipher_aes_ctr, data)
  
  # ChaCha20
  cipher_chacha20 = ChaCha20.new(key=key_chacha20, nonce=nonce)
  time_chacha20 = measure_encryption_time(cipher_chacha20, data)
  
  time_aes_cbc, time_aes_ctr, time_chacha20

  ````
  Results:
  ![sc1](https://github.com/firstnuel/CryptoCourse-Exercises/blob/main/Week%203/sc1.png)
  
-------

  
### Task 2: Partial collisions and preimages of hash functions

Task 2.1

To implement a partial collision search for different hash functions (MD5, SHA-1, SHA-3, etc.) and find partially colliding messages for the first 2-4 bytes of the hash value, we'll follow these steps:

- Hash Function Selection: I'll choose MD5, SHA-1, and SHA-3 for this demonstration.
- Collision Search: I'll generate random messages and calculate their hash values until we find two different messages that have the same first few bytes in their hash values.
- Partial Collision: I'll focus on finding a collision in the first 2-4 bytes of the hash.
- Time Measurement: I'll measure the time taken to find each collision.

````py
  import hashlib
  import time
  import random
  import string
  
  # Function to generate a random message
  def generate_random_message(length=10):
      letters = string.ascii_letters + string.digits
      return ''.join(random.choice(letters) for i in range(length))
  
  # Function to find partial collision
  def find_partial_collision(hash_function, bytes_to_match=2):
      start_time = time.time()
      seen_hashes = {}
      while True:
          message = generate_random_message()
          hash_digest = hash_function(message.encode()).hexdigest()
          short_hash = hash_digest[:bytes_to_match*2]  # 2 hex chars per byte
          if short_hash in seen_hashes:
              return message, seen_hashes[short_hash], hash_digest, time.time() - start_time
          else:
              seen_hashes[short_hash] = message
  
  # Finding partial collisions
  collision_md5 = find_partial_collision(hashlib.md5, 2)
  collision_sha1 = find_partial_collision(hashlib.sha1, 2)
  collision_sha3 = find_partial_collision(hashlib.sha3_256, 2)
  
  print(collision_md5)
  print(collision_sha1)
  print(collision_sha3)
````
![sc2](https://github.com/firstnuel/CryptoCourse-Exercises/blob/main/Week%203/sc2.png)

Results
1. MD5 Collision:

- Colliding Messages: '534Tz9hTUu' and 'BaFDcxxWuD'
- Common Hash Prefix: be85
- Time Taken: Approximately 0.002 seconds

2. SHA-1 Collision:

- Colliding Messages: 'ReqLj08enn' and 'WJINESvhiJ'
- Common Hash Prefix: 55df
- Time Taken: Approximately 0.00088 seconds
  
3. SHA-3 Collision:

- Colliding Messages: 'XLj1oaanHr' and 'yyndNUny2w'
- Common Hash Prefix: b55d
- Time Taken: Approximately 0.00067 seconds

Task 2.2

Implementing a partial preimage search for a hash function like MD5 or SHA-1 involves finding a message that, when hashed, results in a hash value that starts with a specified number of zero bytes. The process is computationally intensive, as it generally requires a brute-force approach.

Steps for this task:

- Hash Function Selection: Choose MD5 for this demonstration.
- Target Hash Prefix: To looking for hash values starting with 1-3 zero bytes (2, 4, or 6 zero hexadecimal characters).
- Preimage Search: Generate random messages and hash them until we find one that matches the target hash prefix.
- Time Measurement: Measure the time taken to find each preimage.

````py
import hashlib
import time
import random
import string

# Function to generate a random message
def generate_random_message(length=10):
    letters = string.ascii_letters + string.digits
    return ''.join(random.choice(letters) for i in range(length))

# Function to find partial preimage
def find_partial_preimage(target_zeros, hash_function):
    target_prefix = '0' * target_zeros
    start_time = time.time()
    while True:
        message = generate_random_message()
        hash_digest = hash_function(message.encode()).hexdigest()
        if hash_digest.startswith(target_prefix):
            return message, hash_digest, time.time() - start_time

# Finding preimages for hash values starting with 1-3 zero bytes
preimage_1_zero = find_partial_preimage(2, hashlib.md5)  # 1 zero byte
preimage_2_zeros = find_partial_preimage(4, hashlib.md5) # 2 zero bytes
preimage_3_zeros = find_partial_preimage(6, hashlib.md5) # 3 zero bytes

preimage_1_zero, preimage_2_zeros, preimage_3_zeros
````
![sc2](https://github.com/firstnuel/CryptoCourse-Exercises/blob/main/Week%203/sc3.png)

1. Preimage for 1 Zero Byte:

- Preimage: '9LiJfjpHdh'
- Hash Value: '006e3aca939fa74ab4356f946428f38a'
- Time Taken: Approximately 0.006 seconds

2.Preimage for 2 Zero Bytes:

- Preimage: 'i1r7qNIylc'
- Hash Value: '0000c195c744511b2fd8d4a52084c911'
- Time Taken: Approximately 0.099 seconds
  
3.Preimage for 3 Zero Bytes:

- Preimage: 'YVHOuod94t'
- Hash Value: '00000013500100742bbf4125f84cf78c'
- Time Taken: Approximately 72.08 seconds

------


Task 4: MACs gone wrong

Approach:
- Analyze the Cookie Format: Understand how the cookie is structured (key, data, hash) and how the server validates it.
- Length Extension Attack: Use an existing tool to perform a length extension attack on the SHA-256 hash. Using  hashpump.
- Create a Modified Cookie: Generate a new valid hash for the modified cookie data (e.g., changing the user role to admin).
- Send a Request with the Modified Cookie: Use Python's requests library to send an HTTP request with the modified cookie to access the /admin/top-secret route.

- Used this code to get the cookie
````py
import requests

# Replace with the actual login URL and credentials
login_url = '"http://0.0.0.0:5000/login'
credentials = {'username': 'cryptonator', 'password': 'cryptonator'}

session = requests.Session()
response = session.post(login_url, data=credentials)

# Retrieve the session cookie
cookie = session.cookies.get_dict()
print(cookie)
````
![sc2](https://github.com/firstnuel/CryptoCourse-Exercises/blob/main/Week%203/sc4.png)

This code parses the  cookie into its components: username, secret, and hash. 

````py
cookie_str = 'dXNlcm5hbWU9Y3J5cHRvbmF0b3I7c2VjcmV0PTQwN2M2OTFmNzlkMDk2NDEyYmFlMmIxMzNlMmQwNTM0MTQxNjcwNDJiNTU5MjhmMzRhMmMxNWM4NDIxMGQyOTc7.WnX5M/8dfvyMsOmjozOaOfx1V37jebyHZBhsgJq/RRc='

# Splitting the cookie into payload and signature
parts = cookie_str.split('.')
payload_b64 = parts[0]
hash_signature = parts[1] if len(parts) > 1 else None

# Decode the payload
try:
    payload = base64.b64decode(payload_b64).decode()
except (base64.binascii.Error, UnicodeDecodeError):
    payload = None

# Extract key, data, and hash from the payload
if payload:
    key_data, _, data_hash = payload.partition(';')
    key, _, data = key_data.partition('=')
else:
    key, data, data_hash = None, None, None

key, data, data_hash, hash_signature
````

![sc2](https://github.com/firstnuel/CryptoCourse-Exercises/blob/main/Week%203/sc5.png)

Modified Cookie:

This script will attempt to create a new cookie that includes the admin=true data with a valid hash, exploiting the length extension vulnerability.
The actual key_length was not known to me so I created a loop to generate a list of possible hashes by generating from all key length values for the `range(10, 20)` using Hashpump

````py
import subprocess
import base64

def hashpump(original_hash, original_data, append_data, key_length):
    # Decoding the original hash from base64
    original_hash_decoded = base64.b64decode(original_hash).hex()

    # No need to decode original_data as it's not base64 encoded
    original_data_decoded = original_data

    process = subprocess.Popen(['hashpump', '-s', original_hash_decoded, '-d', original_data_decoded, '-a', append_data, '-k', str(key_length)], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output, error = process.communicate()

    if error:
        print(f"Error with key length {key_length}:", error.decode())
        return None, None

    try:
        new_hash, new_data = output.decode().strip().split('\n')
        return new_hash, new_data
    except ValueError:
        print(f"Failed to unpack output with key length {key_length}:", output.decode())
        return None, None

def modify_cookie(original_hash, original_data, append_data):
    modified_cookies = []
    
    for key_length in range(10, 20):
        new_hash, new_data = hashpump(original_hash, original_data, append_data, key_length)

        if new_hash and new_data:
            # Encoding new data to base64
            new_data_b64 = base64.b64encode(new_data.encode()).decode()

            # Creating the new cookie
            modified_cookie = f"{new_data_b64}.{new_hash}"
            modified_cookies.append(modified_cookie)

    return modified_cookies

# Extracted details from the provided cookie
original_hash = 'WnX5M/8dfvyMsOmjozOaOfx1V37jebyHZBhsgJq/RRc='
original_data = 'username=cryptonator;secret=407c691f79d096412bae2b133e2d053414167042b55928f34a2c15c84210d297'
append_data = 'admin=true'  # Data you want to append

modified_cookies = modify_cookie(original_hash, original_data, append_data)

# Print the list of modified cookies
print("Modified Cookies:", modified_cookies)

````
![sc2](https://github.com/firstnuel/CryptoCourse-Exercises/blob/main/Week%203/sc6.png)

Send a Request with the Modified Cookie:

For each cookie in the list, the code creates a new session, sets the modified cookie, and sends a GET request to the URL. It then prints out the status code for each request, which will helps to understand how the server responds to each modified cookie.

````py
import requests

def try_modified_cookies(url, modifiedcookies):
    for i, cookie in enumerate(modifiedcookies):
        # Creating a session object to handle cookies
        session = requests.Session()

        # Adding the modified cookie to the session
        session.cookies.set('auth', cookie, domain='localhost', path='/')

        # Sending a GET request to the target URL with the modified cookie
        response = session.get(url)

        # Print the response status code for each cookie
        print(f"Cookie {i+1} status code: {response.status_code}")

# The URL of the web application
url = "http://0.0.0.0:5000/admin/top-secret"
try_modified_cookies(url, modified_cookies)
````
![sc2](https://github.com/firstnuel/CryptoCourse-Exercises/blob/main/Week%203/sc7.png)

I couldn't successfully access the route `/admin/top-secret` 
