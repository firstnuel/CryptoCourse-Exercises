# Week 3: Stream ciphers and hash functions

### Task 1: Stream cipher usage

Task 1.1
- The ciphertext for "Move the chairs to the house as soon as possible!" that will decrypt to the desired plaintext under the same keystream used for "Move the tables to the patio as soon as possible!" is:

  a7896ad1b2f7da8d40a434173df74a839a88b5c9a97625e65e16bfebfb542072595d804d5ad1a3af11ea7244a39d76cde1

- Code used
   ````py
   # Original and desired plaintexts
  original_plaintext = "Move the tables to the patio as soon as possible!"
  desired_plaintext = "Move the chairs to the house as soon as possible!"
  
  # Provided ciphertext for the original plaintext
  original_ciphertext_hex = "a7896ad1b2f7da8d40b33d1438e04a839a88b5c9a97625fe5017a5e1fb542072595d804d5ad1a3af11ea7244a39d76cde1"
  
  # Convert hex ciphertext to bytes
  original_ciphertext_bytes = bytes.fromhex(original_ciphertext_hex)
  
  # Function to XOR two byte sequences
  def xor_bytes(byte_seq1, byte_seq2):
      return bytes(a ^ b for a, b in zip(byte_seq1, byte_seq2))
  
  # Generating the keystream by XORing the original plaintext with its ciphertext
  keystream = xor_bytes(original_plaintext.encode(), original_ciphertext_bytes)
  
  # Encrypting the desired plaintext with the keystream
  desired_ciphertext_bytes = xor_bytes(desired_plaintext.encode(), keystream)
  
  # Converting the desired ciphertext to hexadecimal representation
  desired_ciphertext_hex = desired_ciphertext_bytes.hex()
  
  desired_ciphertext_hex
   
  ````


- This ciphertext was generated by XORing the desired plaintext with the keystream derived from the original plaintext and its provided ciphertext. Notice that the beginning and ending parts of the ciphertext are the same for both messages. This similarity occurs because the same segments of plaintext ("Move the" and "as soon as possible!") were encrypted with the same part of the keystream.


Task 1.2

To illustrate the process of encryption with a key and nonce, and to observe the effects of slight changes in the plaintext with different keys but the same nonce.

1. Selected Messages:

- Message 1: "Big high dive!"
- Message 2: "Big high five!"!" (changed 'D' to 'F')
  
2. Chosen Keys and Nonce:

- Key 1: "key12345key12345" (16 bytes for AES)
- Key 2: "key54321key54321" (another 16 bytes key)
- Nonce: "nonce1234567890" (16 bytes)
  
3. Encryption Process:

- Using AES in CTR (Counter) mode for encryption, as it allows the use of a nonce.
Encrypt both messages with their respective keys and the same nonce.

4. Observation:

- Ciphertext for "Big high dive!": 234886ed8efb00787f51cfba770a
- Ciphertext for "Big high five!": 7ee6dbfae3001e35e29107bbb4be

- When comparing these ciphertexts, we find no obvious pattern or relationship between them. The change from 'd' to 'f' in the plaintexts does not result in a recognizable pattern in the ciphertexts when different keys are used, even with the same nonce. This absence of a visible relationship is a fundamental aspect of secure encryption: even small changes in plaintext or the use of different keys should result in completely unrelated and seemingly random ciphertexts. This characteristic ensures the security and confidentiality of the encrypted data. ​​

- Code used
  ````py
    #  Messages
  message_1 = "Big high dive!"
  message_2 = "Big high five!" # 'd' changed to 'f'
  
  # Encrypt both messages using the defined function and keys
  ciphertext_1 = encrypt_aes_ctr(message_1, key1, nonce)
  ciphertext_2 = encrypt_aes_ctr(message_2, key2, nonce)
  
  # Convert ciphertexts to hex for easier comparison
  ciphertext1_hex = ciphertext_1.hex()
  ciphertext2_hex = ciphertext_2.hex()
  
  ciphertext1_hex, ciphertext2_hex
  ````
Task 1.3

Comparing the encryption speed of AES-CBC, AES-CTR, and a selected stream cipher, I will conduct a basic performance test in Python. For the stream cipher, I'll use ChaCha20, a widely-used and secure stream cipher. The test will involve encrypting a reasonably large amount of data to minimize the impact of system noise on the results.

Test Setup
- Data Size: To encrypt a large enough data block, such as 10 MB, to ensure the results are not heavily influenced by system overhead or noise.

Cipher Configuration:
- AES-CBC and AES-CTR: Both use a 256-bit key.

- ChaCha20: Uses its standard configuration.

Performance Measurement
- To measure the time taken to encrypt the data for each cipher.
The encryption times for the 10 MB data using different ciphers are as follows:

- AES-CBC: Approximately 0.0236 seconds
- AES-CTR: Approximately 0.0097 seconds
- ChaCha20: Approximately 0.027 seconds
  
Observations:
- AES-CTR is the fastest, which aligns with the expectation that counter mode (CTR) generally has a performance advantage due to its parallelizable nature and simpler implementation.
- AES-CBC is faster on my system compared to ChaCha20, which is quite interesting. This could be due to hardware acceleration for AES (like AES-NI) being present on my system. AES-NI significantly boosts AES encryption/decryption speeds and is commonly available in modern processors.
- ChaCha20, while slower than both AES modes on my system, still shows a competitive performance. This cipher is often favored in environments where hardware acceleration for AES is not available, as it provides a good balance of security and performance, especially on mobile and lower-power devices.

Hardware Support:
- The Python environment used for this test does not explicitly utilize hardware acceleration features like AES-NI, which are available in modern CPUs for AES encryption.
On systems with hardware acceleration, AES encryption (both CBC and CTR modes) would likely be significantly faster, possibly outperforming ChaCha20.

Conclusion:
- The difference in encryption speed is noticeable but not drastic in this test environment. However, the actual performance can vary based on the hardware and specific implementation.
In more practical applications, the choice between these ciphers should also consider factors like security requirements, hardware capabilities, and the specific nature of the data and system architecture

- Code Used
  ````py
  import time
  from Crypto.Cipher import AES, ChaCha20
  from Crypto.Random import get_random_bytes
  
  # Test data setup
  data = get_random_bytes(10 * 1024 * 1024)  # 10 MB of random data
  key_aes = get_random_bytes(32)  # 256-bit key for AES
  key_chacha20 = get_random_bytes(32)  # 256-bit key for ChaCha20
  iv = get_random_bytes(16)  # Initialization vector for AES-CBC
  nonce = get_random_bytes(8)  # Nonce for AES-CTR and ChaCha20
  
  # Function to measure encryption time
  def measure_encryption_time(cipher, data):
      start_time = time.time()
      cipher.encrypt(data)
      end_time = time.time()
      return end_time - start_time
  
  # AES-CBC
  cipher_aes_cbc = AES.new(key_aes, AES.MODE_CBC, iv)
  time_aes_cbc = measure_encryption_time(cipher_aes_cbc, data)
  
  # AES-CTR
  cipher_aes_ctr = AES.new(key_aes, AES.MODE_CTR, nonce=nonce)
  time_aes_ctr = measure_encryption_time(cipher_aes_ctr, data)
  
  # ChaCha20
  cipher_chacha20 = ChaCha20.new(key=key_chacha20, nonce=nonce)
  time_chacha20 = measure_encryption_time(cipher_chacha20, data)
  
  time_aes_cbc, time_aes_ctr, time_chacha20

  ````
  Results:
  ![sc1](https://github.com/firstnuel/CryptoCourse-Exercises/blob/main/Week%203/sc1.png)
