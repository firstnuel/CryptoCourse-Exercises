# Week 3: Stream ciphers and hash functions

### Task 1: Stream cipher usage

Task 1.1
- The ciphertext for "Move the chairs to the house as soon as possible!" that will decrypt to the desired plaintext under the same keystream used for "Move the tables to the patio as soon as possible!" is:

  a7896ad1b2f7da8d40a434173df74a839a88b5c9a97625e65e16bfebfb542072595d804d5ad1a3af11ea7244a39d76cde1

- Code used
   ````py
   # Original and desired plaintexts
  original_plaintext = "Move the tables to the patio as soon as possible!"
  desired_plaintext = "Move the chairs to the house as soon as possible!"
  
  # Provided ciphertext for the original plaintext
  original_ciphertext_hex = "a7896ad1b2f7da8d40b33d1438e04a839a88b5c9a97625fe5017a5e1fb542072595d804d5ad1a3af11ea7244a39d76cde1"
  
  # Convert hex ciphertext to bytes
  original_ciphertext_bytes = bytes.fromhex(original_ciphertext_hex)
  
  # Function to XOR two byte sequences
  def xor_bytes(byte_seq1, byte_seq2):
      return bytes(a ^ b for a, b in zip(byte_seq1, byte_seq2))
  
  # Generating the keystream by XORing the original plaintext with its ciphertext
  keystream = xor_bytes(original_plaintext.encode(), original_ciphertext_bytes)
  
  # Encrypting the desired plaintext with the keystream
  desired_ciphertext_bytes = xor_bytes(desired_plaintext.encode(), keystream)
  
  # Converting the desired ciphertext to hexadecimal representation
  desired_ciphertext_hex = desired_ciphertext_bytes.hex()
  
  desired_ciphertext_hex
   
  ````


- This ciphertext was generated by XORing the desired plaintext with the keystream derived from the original plaintext and its provided ciphertext. Notice that the beginning and ending parts of the ciphertext are the same for both messages. This similarity occurs because the same segments of plaintext ("Move the" and "as soon as possible!") were encrypted with the same part of the keystream.


Task 1.2

To illustrate the process of encryption with a key and nonce, and to observe the effects of slight changes in the plaintext with different keys but the same nonce.

1. Selected Messages:

- Message 1: "Big high dive!"
- Message 2: "Big high five!"!" (changed 'D' to 'F')
  
2. Chosen Keys and Nonce:

- Key 1: "key12345key12345" (16 bytes for AES)
- Key 2: "key54321key54321" (another 16 bytes key)
- Nonce: "nonce1234567890" (16 bytes)
  
3. Encryption Process:

- Using AES in CTR (Counter) mode for encryption, as it allows the use of a nonce.
Encrypt both messages with their respective keys and the same nonce.

4. Observation:

- Ciphertext for "Big high dive!": 234886ed8efb00787f51cfba770a
- Ciphertext for "Big high five!": 7ee6dbfae3001e35e29107bbb4be

- When comparing these ciphertexts, we find no obvious pattern or relationship between them. The change from 'd' to 'f' in the plaintexts does not result in a recognizable pattern in the ciphertexts when different keys are used, even with the same nonce. This absence of a visible relationship is a fundamental aspect of secure encryption: even small changes in plaintext or the use of different keys should result in completely unrelated and seemingly random ciphertexts. This characteristic ensures the security and confidentiality of the encrypted data. ​​

- Code used
  ````py
    #  Messages
  message_1 = "Big high dive!"
  message_2 = "Big high five!" # 'd' changed to 'f'
  
  # Encrypt both messages using the defined function and keys
  ciphertext_1 = encrypt_aes_ctr(message_1, key1, nonce)
  ciphertext_2 = encrypt_aes_ctr(message_2, key2, nonce)
  
  # Convert ciphertexts to hex for easier comparison
  ciphertext1_hex = ciphertext_1.hex()
  ciphertext2_hex = ciphertext_2.hex()
  
  ciphertext1_hex, ciphertext2_hex
  ````

